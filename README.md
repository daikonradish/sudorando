# sudorando

This package is a proof of concept that a pure-Gleam implementation of a pseudorandom number generator can be written with a [mutable atomic array](https://github.com/lpil/atomic-array) as the internal state. 

# What is a pseudorandom number generator?

Random numbers are useful in many applications. For example, game developers may require a random number generator to simulate the flip of a coin, or the draw of a poker hand. But computers are determistic. True randomness is not possible. Instead, computers simulate randomness by creating a deterministic sequence of numbers:

```
Seed
 |
 V
State 
 x1,  x2,      x3,         x4,          x5...
      
 x1, f(x1), f(f(x1)), f(f(f(x1))), f(f(f(f(x1)))),,,
 
Note: in practice, x could be an integer, or an n-dimensional vector of integers. 
```

In this case, the first number is called the seed, and the subsequent numbers are generated by iterativel applying a generating function, `f`. This function is typically chosen to ensure that the next value in the sequence jumps around the integers in a fashion that appears unpredictable, so the end user might think it looks random.

# Concerns within immutable programming languages

Immutable programming languages like Gleam do not typically embrace mutable state. This means that creating random number generators, which _require_ internal mutable state, can be awkward. In Gleam, libraries like [PRNG](https://github.com/giacomocavalieri/prng) choose to explicitly pass the state around, with the following type signature: `Seed -> #(a, Seed)`. Getting two values from the same sequence requires the user to manage the state manually. The [author of the language](https://github.com/giacomocavalieri) claimed in the Gleam Discord that this method is how immutable languages manage applications that require internal state. However, here is a summary of how other immutable languages generate seeded sequences of pseudorandom numbers: 

| Language | Module        | Set seed                             | Random generation                                                                                                                                      | Pass state explicity |
| :------- | :------------ | :----------------------------------- | :----------------------------------------------------------------------------------------------------------------------------------------------------- | :------------------- |
| Ocaml    | random        | Set systemwide seed                  | Calling a method.                                                                                                                                      | No                   |
| Haskell  | System.Random | Instantiate Generator from Int input | Calling a method in the state monad (primiitve state for MWC-random). State is passed around implicitly within the context of the state monad.         | No                   |
| Clojure  | Use Java      | Instantiate Generator from Int input | Java's API is object oriented: instantiate once, and Java manages internal state in JVM.                                                               | No                   |
| Rust     | rand_crate    | Instantiate Generator from Int input | Calling a method                                                                                                                                       | No                   |
| Erlang   | rand          | Set module-level seed                | Generator can return a value and a new state, which the user can choose to manage. However, the API can also manage the state implicitly for the user. | No                   |
| Scala    | Use Java      | Instantiate Generator from Int input | Java's API is object oriented: instantiate once, and Java manages internal state in JVM.                                                               | No                   |
| Elm      | random        | Instantiate Generator from Int input | Generator returns value and new state. Generator state must be explicitly handled by the user.                                                         | Yes                  |
| Gleam    | prng          | Instantiate Generator from Int input | Generator returns value and new state. Generator state must be explicitly handled by the user.                                                         | Yes                  |

# Sidenote: Gleam lacks infinite sequences

Though it is a functional language, Gleam lacks the ability to generate infinite sequences. In many other of function and immutable languages above, random number generation is actually modeled as an infinite sequence of `f` iteratively applied to `x1`, the initial state. The user interacts with this sequence using usual list abstractions, like pattern matching, `take`, `drop`, etc. Therefore there is no explicit need for the user to handle state. 

In Gleam, this appears to be the functionality offered by the [Yielder API](https://github.com/gleam-lang/yielder). However, this API appears to be in the process of being deprecated: the Discord is full of admonishments to not use it, and core team warns against it. Not much documented evidence of its deprecation exists other than in the Discord server.

For this reason and several others, Gleam developers with significant experience in other functional languages may feel that Gleam lacks the expressiveness of other functional languages. In other words, Gleam is a functional language with a limited emphasis on functions (and their combinators).

# Motivation behind this library

This was originally an motivated by the following:

1. _Speed_. There was anecdotal evidence that [PRNG](https://github.com/giacomocavalieri/prng) is slow. 
2. _API_. Passing the internal state around affects user ergonomics.
  1. A user could be using two random number generators, and mix up the internal state.
  2. The internal state cannot be used for anything other than reading from it generates a pseudorandom number
3. _Exploring limited mutability_. Mutability has a place in many immutable languages if used in a limited context. (See point 1, speed.)


# Results

7 runs were conducted. Each run corresponds to 10000 runs of generating a random float within the unit (0, 1)

Prng was approximately 3 times slower. 

| Run   | Prng (MS)  | Sudorando (MS) |
| :---- | :----- | :-------- |
| 1     | 5.6146 | 1.6703    |
| 2     | 5.8903 | 1.6333    |
| 3     | 5.4096 | 1.6381    |
| 4     | 5.5294 | 1.6402    |
| 5     | 5.5856 | 1.6421    |
| 6     | 5.5161 | 1.6298    |
| 7     | 5.5599 | 1.64      |

# Next steps

1. From these benchmarks, it is clear that _limited_ mutability can have its place within a functional language. Of course, these situations should be clearly highlighted to the end user, and the interface should be limited.
2. Not all immutable languages require state to be explicitly passed around by the user in order to generate a new randum number. Research shows that explicit state handling for random number generation is actually in the minority.

## How to run benchmarks

```sh
gleam run   # Run the project
gleam dev console  # Run the tests
```
